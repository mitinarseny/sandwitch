pragma solidity ^0.8.19;

bytes1 constant ALLOW_FAILURE = bytes1(uint8(1) << 7);
bytes1 constant WITH_VALUE    = bytes1(uint8(1) << 6);

contract MultiCall {
  enum Command {
    Group,
    Call,
    CallValue, // also used for Transfer
    GetBalanceOf,
    Create,
    CreateValue,
    Create2,
    Create2Value
  }

  struct Result {
    bool success;
    bytes output;
  }

  error Failed(uint256 index, bytes data);

  constructor() payable {}

  function multicall(bytes[] calldata calls) external payable returns (Result[] memory results) {
    uint256 len = calls.length;
    results = new Result[](len);

    bytes1 command;
    bytes calldata inputs;
    Result memory result;

    for (uint256 i; i < len;) {
      command = calls[i][0];
      inputs = calls[i][1:];
      result = results[i];

      (result.success, result.output) = dispatch(Command(uint8(command & ~ALLOW_FAILURE)), inputs);
      if (!((command & ALLOW_FAILURE != 0) || result.success)) {
        revert Failed(i, result.output);
      }

      unchecked { ++i; }
    }
  }

  function dispatch(Command cmd, bytes calldata inputs) internal returns (bool success, bytes memory output) {
    if (cmd == Command.Group) {
      return address(this).delegatecall(bytes.concat(this.multicall.selector, inputs));
    }

    if (cmd == Command.GetBalanceOf) {
      address target = inputs.length > 0 ? address(bytes20(inputs)) : address(this);
      return (true, abi.encodePacked(target.balance));
    }

    uint256 value;
    if (cmd == Command.CallValue || cmd == Command.CreateValue || cmd == Command.Create2Value) {
      value = uint256(bytes32(inputs));
      inputs = inputs[32:];
    }

    if (cmd == Command.Call || cmd == Command.CallValue) {
      address target = address(bytes20(inputs));
      return target.call{value: value}(inputs[20:]);
    }

    address addr;
    if (cmd == Command.Create || cmd == Command.CreateValue) {
      assembly ("memory-safe") {
        let p := mload(0x40)
        mstore(0x40, add(p, inputs.length))
        calldatacopy(p, inputs.offset, inputs.length)

        addr := create(value, p, inputs.length)
      }
    } else { // Command.Create2[Value]
      uint256 salt = uint256(bytes32(inputs));
      inputs = inputs[32:];

      assembly ("memory-safe") {
        let p := mload(0x40)
        mstore(0x40, add(p, inputs.length))
        calldatacopy(p, inputs.offset, inputs.length)

        addr := create2(value, p, inputs.length, salt)
      }
    }
    if (success = (addr != address(0))) {
      output = abi.encodePacked(addr);
    }
  }
}
